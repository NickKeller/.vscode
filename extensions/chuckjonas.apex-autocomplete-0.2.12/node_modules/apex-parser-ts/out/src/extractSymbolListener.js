"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class Position {
    constructor(line, column) {
        this.line = line;
        this.column = column;
    }
}
exports.Position = Position;
class Source {
    constructor(start, stop) {
        this.start = start;
        this.stop = stop;
    }
}
exports.Source = Source;
class Symbol {
    constructor(source, name, type, attributes) {
        this.source = source;
        this.name = name;
        this.type = type;
        this.attributes = attributes;
    }
}
exports.Symbol = Symbol;
class SymbolTable {
    constructor(parentTable) {
        this.parentTable = parentTable;
        this.symbols = new Map();
    }
    insert(symbol) {
        this.symbols.set(symbol.source.text, symbol);
    }
}
exports.SymbolTable = SymbolTable;
class ExtractSymbolListener {
    constructor(parser) {
        this.parser = parser;
        this.symbolTable = new SymbolTable(null);
    }
    enterClassDeclaration(ctx) {
        let tokens = this.parser.inputStream;
        let source = new Source(ctx.start, ctx.stop);
        source.text = tokens.getText(ctx);
        let className = ctx.className().text;
        //set class if top level
        if (!this.class) {
            this.class = className;
        }
        let sym = new Symbol(source, className, className, null);
        sym.symbolType = 'class';
        this.symbolTable.insert(sym);
    }
    enterClassConstructor(ctx) {
        let tokens = this.parser.inputStream;
        let source = new Source(ctx.start, ctx.stop);
        source.text = tokens.getText(ctx);
        let id = ctx.qualifiedName().text;
        let params = this.generateParametersObject(ctx.methodParameters());
        let sym = new Symbol(source, id, id, { params: params });
        sym.symbolType = 'constructor';
        this.symbolTable.insert(sym);
    }
    enterClassProperty(ctx) {
        let tokens = this.parser.inputStream;
        let source = new Source(ctx.start, ctx.stop);
        source.text = tokens.getText(ctx);
        let type = "void";
        if (ctx.dataType() != null) {
            type = tokens.getText(ctx.dataType());
        }
        let id = ctx.propertyName().text;
        let sym = new Symbol(source, id, type, null);
        sym.symbolType = 'field';
        this.symbolTable.insert(sym);
    }
    /* === LISTENERS === */
    enterClassMethod(ctx) {
        let tokens = this.parser.inputStream;
        let source = new Source(ctx.start, ctx.stop);
        source.text = tokens.getText(ctx);
        let header = ctx.methodHeader();
        let type = "void";
        if (header.dataType() != null) {
            type = tokens.getText(header.dataType());
        }
        let params = this.generateParametersObject(header.methodParameters());
        let sym = new Symbol(source, header.methodName().text, type, { params: params });
        sym.symbolType = 'method';
        this.symbolTable.insert(sym);
    }
    generateParametersObject(paramsCtx) {
        let params = [];
        if (!paramsCtx) {
            return params;
        }
        paramsCtx.methodParameter().forEach((param) => {
            params.push({
                type: param.dataType().text,
                name: param.methodParameterName().text
            });
        });
        return params;
    }
}
exports.ExtractSymbolListener = ExtractSymbolListener;
//# sourceMappingURL=extractSymbolListener.js.map